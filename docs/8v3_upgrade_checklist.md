# 8个拦截弹对抗3个来袭导弹的改造清单

下列条目按照“为什么需要调整 → 需要修改的内容 → 修改后的作用”给出，请在实施前逐项确认。

## 1. 场景基础参数
- **拦截弹数量改成 8 枚**  
  - *原因*：当前环境构造函数默认只初始化 6 枚拦截弹，会导致多出来的两枚从未建模。  
  - *修改*：在 `ManeuverEnv` 初始化参数中把 `InterceptorNum` 默认值调成 8，或者在所有创建环境的调用处显式传入 8（`Environment/init_env.py` 第 16-80 行调用 `ManeuverEnv` 时未传递该参数，因此默认值会生效）。【F:Environment/env.py†L28-L60】【F:Environment/init_env.py†L16-L80】  
  - *作用*：确保环境内的拦截弹列表、剩余数量等状态与真实战术设定一致。
- **来袭导弹数量改成 3 枚**  
  - *原因*：初始化与重置函数仍按 2 枚导弹生成状态，导致仿真依旧在 6v2 的旧规模下运行。  
  - *修改*：在 `init_env` 与 `reset_para` 的默认参数中将 `num_missiles` 调整为 3，并更新 `ManeuverEnv.reset()` 中的本地常量（当前写死为 2）。【F:Environment/init_env.py†L16-L80】【F:Environment/reset_env.py†L13-L95】【F:Environment/env.py†L806-L848】  
  - *作用*：重置与采样时生成 3 枚导弹的初始状态，使训练/验证场景与需求匹配。

## 2. 状态与动作空间
- **观测矩阵尺寸随规模同步扩展**  
  - *原因*：状态拼接依赖 `self.missileNum` 与 `self.interceptorNum` 计算形状，但外部工具存在硬编码（例如预测脚本直接把状态还原成 9×6 矩阵，对应旧的 1+2+6 个实体）。  
  - *修改*：将 `utils/predict.py` 中的 `resize_flattenState`、`statefromEnv` 等初始化改为按 `1 + missileNum + interceptorNum` 生成维度，并检查其它脚本是否固定写死 9 行。【F:utils/predict.py†L24-L167】  
  - *作用*：保证渲染、回放与分析阶段能正确读取 12×6（飞机1 + 导弹3 + 拦截弹8）状态。
- **动作库与目标索引**  
  - *原因*：动作库内部遍历 `range(-1, missile_num)`，确保导弹索引上限正确即可，但需要确认调用方传入的 `missile_num` 与环境保持一致。  
  - *修改*：若外部仍用旧的 2 枚配置调用 `getActionDepository`，需同步更新入参；若只使用 `getNewActionDepository` 则无需额外操作。建议在生成器位置加断言以避免再次错配。【F:Environment/ActionDepository.py†L34-L53】  
  - *作用*：避免因索引越界导致的训练崩溃或漏打目标。

## 3. 拦截弹发射与锁定策略
- **Lock 约束与发射节奏复核**  
  - *原因*：`LockConstraint` 目前限制某目标最多被 `interceptorNum/2`（现在为 4）枚拦截弹同时追踪；规模变化后需要评估是否仍合理。  
  - *修改*：根据新的火力分配策略调整阈值、或改成按来袭导弹数量占比来限制；同时检查 `LanchGap=100` 是否仍满足 8 枚弹的发射节奏需求。【F:Environment/env.py†L585-L616】【F:Environment/env.py†L832-L872】  
  - *作用*：保证拦截弹分配符合新的战术节奏，避免集中过度或释放过慢。
- **剩余拦截弹奖励项**  
  - *原因*：`commonReward` 中 `rm = self.interceptor_remain * C3`，当危险时 `C3 = -DANGERSCALE / interceptorNum`，拦截弹越多单枚罚分越小，可能削弱鼓励。  
  - *修改*：考虑把该项按“锁定目标数量”或“危险导弹数量”归一化，使 8 枚弹时仍能产生足够驱动力。【F:Environment/env.py†L488-L497】  
  - *作用*：维持在危险时快速指派正确目标的激励力度。

## 4. 奖励函数权重与阈值
- **远距离发射惩罚 (`ERRACTIONSCALE`)**  
  - *原因*：多出两枚拦截弹后远距离误射的成本增加，可考虑适度放大 `ERRACTIONSCALE` 或按剩余弹量动态缩放。  
  - *修改*：在文件顶部常量区调整默认值，并评估训练稳定性。【F:Environment/env.py†L16-L448】  
  - *作用*：防止因为弹量充足而频繁在远距离浪费拦截弹。
- **危险距离与加权 (`DANGER_DISTANCE`, `DANGERSCALE`)**  
  - *原因*：3 枚导弹同时逼近时，危险阈值与加权强度会显著影响策略切换。可根据新威胁模型重新标定危险距离或增加与导弹数量相关的加权项。  
  - *修改*：结合实测数据调整常量，并验证 `distanceReward`、`commonReward` 在危险标志触发时的梯度是否过激或不足。【F:Environment/env.py†L16-L520】  
  - *作用*：让奖励在 3 枚导弹并进时能及时提醒策略聚焦最近威胁。
- **威胁度奖励的基线**  
  - *原因*：`CalTreat` 会随着导弹数量增加而出现更高峰值，可能导致奖励分布变化。  
  - *修改*：重新归一化 `commonReward` 尾部的威胁项（例如按导弹数量平均），并检查断言阈值是否仍适用。【F:Environment/env.py†L500-L520】  
  - *作用*：保持奖励值在可控范围，便于网络学习。

## 5. 训练与评估脚本
- **训练、预测、验证入口的参数同步**  
  - *原因*：`train.py`、`predict.py`、`validate.py` 仍把 `num_missiles` 设为 2，会让训练与评估停留在旧场景。  
  - *修改*：将这些脚本的默认参数改为 3，并根据需要增加命令行参数以灵活切换；训练前删除旧模型或使用新目录存放 8v3 权重，避免维度不匹配。【F:utils/train.py†L182-L239】【F:utils/predict.py†L35-L167】【F:utils/validate.py†L30-L208】  
  - *作用*：全流程使用一致的 8v3 环境，避免模型、日志与真实需求脱节。
- **模型结构与检查点**  
  - *原因*：状态维度从 22 扩展到 38，旧模型权重无法直接复用。  
  - *修改*：重新初始化并训练网络；保存路径请区分新旧场景，或在加载时增加形状校验。  
  - *作用*：保证网络输入层尺寸正确，防止加载旧权重时报错。

## 6. 数据记录与可视化
- **日志/CSV 与可视化脚本**  
  - *原因*：任何统计导出、CSV 字段或图例文字中若写死了导弹/拦截弹数量，需要同步更新（例如图例 `methods` 只列出“拦截弹群”单一类别，可考虑细化到 8 枚）。【F:utils/predict.py†L169-L195】  
  - *修改*：根据新的对象数量调整图例、颜色列表、统计字段长度。  
  - *作用*：保证仿真结果展示与实际对象数量一致，便于分析决策。

如确认无遗漏，可按以上顺序逐项实施和回归测试。
